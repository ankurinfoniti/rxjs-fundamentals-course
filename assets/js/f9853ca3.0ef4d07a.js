"use strict";(self.webpackChunkrxjs_fundamentals_course=self.webpackChunkrxjs_fundamentals_course||[]).push([[875],{5613:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return i},contentTitle:function(){return l},metadata:function(){return p},toc:function(){return c},default:function(){return m}});var n=a(7462),r=a(3366),o=(a(7294),a(3905)),s=["components"],i={id:"part-2",title:"Part 2. Reactive programming and RxJS"},l="Reactive programming and RxJS",p={unversionedId:"part-2",id:"part-2",isDocsHomePage:!1,title:"Part 2. Reactive programming and RxJS",description:"Contributors:",source:"@site/docs/part-2.md",sourceDirName:".",slug:"/part-2",permalink:"/rxjs-fundamentals-course/docs/part-2",editUrl:"https://github.com/this-is-learning/rxjs-fundamentals-course/edit/main/docs/part-2.md",tags:[],version:"current",frontMatter:{id:"part-2",title:"Part 2. Reactive programming and RxJS"},sidebar:"tutorialSidebar",previous:{title:"Part 1. RxJS: Better async programming",permalink:"/rxjs-fundamentals-course/docs/part-1"},next:{title:"Part 3. The most common RxJS operators",permalink:"/rxjs-fundamentals-course/docs/part-3"}},c=[{value:"Chapter 2: Reactive Programming with RxJS",id:"chapter-2-reactive-programming-with-rxjs",children:[]},{value:"Chapter Contents:",id:"chapter-contents",children:[]},{value:"Declarative and Imperative Programming",id:"declarative-and-imperative-programming",children:[]},{value:"Reactive Programming",id:"reactive-programming",children:[]},{value:"The Iterator and Observer patterns",id:"the-iterator-and-observer-patterns",children:[]},{value:"Streams of Data",id:"streams-of-data",children:[]},{value:"Observables - an implementation of the Observer pattern",id:"observables---an-implementation-of-the-observer-pattern",children:[]},{value:"Operators - composition with Observables",id:"operators---composition-with-observables",children:[]}],h={toc:c};function m(e){var t=e.components,a=(0,r.Z)(e,s);return(0,o.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"reactive-programming-and-rxjs"},"Reactive programming and RxJS"),(0,o.kt)("p",null,"Contributors:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Nate Lapinski"),(0,o.kt)("li",{parentName:"ul"},"Alain Boudard"),(0,o.kt)("li",{parentName:"ul"},"Maina Wycliffe")),(0,o.kt)("h1",{id:"fundamentals-of-rxjs"},"Fundamentals of RxJS"),(0,o.kt)("h2",{id:"chapter-2-reactive-programming-with-rxjs"},"Chapter 2: Reactive Programming with RxJS"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"What is declarative programming ?"),(0,o.kt)("li",{parentName:"ul"},"What is the Observer pattern, and how does it relate to the Iterator pattern ?")),(0,o.kt)("p",null,"And many others. Along the way, we'll build a very simple Observable of our own, and we'll even touch on a couple of topics from the world of functional programming."),(0,o.kt)("h2",{id:"chapter-contents"},"Chapter Contents:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Declarative and Imperative programming"),(0,o.kt)("li",{parentName:"ul"},"Reactive Programming"),(0,o.kt)("li",{parentName:"ul"},"The Iterator and Observer patterns"),(0,o.kt)("li",{parentName:"ul"},"arrays as iterables"),(0,o.kt)("li",{parentName:"ul"},"iterators as pull"),(0,o.kt)("li",{parentName:"ul"},"observers as push"),(0,o.kt)("li",{parentName:"ul"},"symmetry between iterators and observers"),(0,o.kt)("li",{parentName:"ul"},"Streams of data"),(0,o.kt)("li",{parentName:"ul"},"Observables - an implementation of the Observer pattern"),(0,o.kt)("li",{parentName:"ul"},"observers"),(0,o.kt)("li",{parentName:"ul"},"subscribers"),(0,o.kt)("li",{parentName:"ul"},"subscriptions and subjects"),(0,o.kt)("li",{parentName:"ul"},"Operators - composition with Observables"),(0,o.kt)("li",{parentName:"ul"},"map and filter"),(0,o.kt)("li",{parentName:"ul"},"pipelines: the flow of data through an observable. Transducers.")),(0,o.kt)("h2",{id:"declarative-and-imperative-programming"},"Declarative and Imperative Programming"),(0,o.kt)("p",null,"The difference between these two styles of programming is perhaps best illustrated with an example."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Challenge: Write a program which takes the array ",(0,o.kt)("inlineCode",{parentName:"strong"},"x = [1,2,3,4,5]"),", and produces a new array, ",(0,o.kt)("inlineCode",{parentName:"strong"},"y"),", by adding one to each element in ",(0,o.kt)("inlineCode",{parentName:"strong"},"x"),". The result should be ",(0,o.kt)("inlineCode",{parentName:"strong"},"[2,3,4,5,6]"),".")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Solution 1: Use a loop")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"let x = [1, 2, 3, 4, 5];\nlet y = [];\n\nfor (let i = 0; i < x.length; i++) {\n  y.push(x[i] + 1);\n}\n\nconsole.log(y); // [2,3,4,5,6]\n")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Solution 2: Use map")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const add1 = (n) => n + 1;\nlet x = [1, 2, 3, 4, 5];\n\nlet y = x.map(add1);\n\nconsole.log(y); // [2,3,4,5,6]\n")),(0,o.kt)("p",null,"The difference between declarative and imperative programming can be a little subtle at first. ",(0,o.kt)("strong",{parentName:"p"},"Solution 1")," is an example of ",(0,o.kt)("em",{parentName:"p"},"imperative programming"),', which is usually described as telling the computer exactly how to calculate what we want, step by step. Notice the loop. We are stepping through each and every element of the array x, and saying how to transform it (by adding 1 to it), and then saying how to place it in the array y (by calling y.push). It\'s a sort of "do step1, then do step2, then do step3\u2026" approach where we explicitly specify everything.'),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Solution 2"),' is an example of declarative programming. Notice how we\'ve shied away from explicit implementation details, and are describing or "declaring" what we want to happen by using the map method from Array.prototype. We\'re simply stating "Take the array x, apply the function add1 to every element, and give me the results in a new array called y".'),(0,o.kt)("p",null,"Sometimes, this difference can feel like a matter of preference. At the end of the day, both solutions produce the correct answer, and there's certainly nothing wrong with loops (we'll see later on how map can be implemented internally using a loop). However, when we deal with asynchronous programming, we'll see that the declarative solution is preferable. Why is that? Notice a couple of things about our two solutions:"),(0,o.kt)("p",null,"Solution 1 is very clearly ",(0,o.kt)("strong",{parentName:"p"},"synchronous")," (a loop must always be synchronous), and it's not ",(0,o.kt)("em",{parentName:"p"},"composable")," (more on this later)."),(0,o.kt)("p",null,"Solution 2 is a little more interesting. x is an array, so we know that this code is synchronous. However, the ",(0,o.kt)("em",{parentName:"p"},"concept")," of mapping over something could very well be asynchronous. We haven't really specified any implementation details with the map, just that we want to apply the function add1 to every element inside of the container x. Maybe those elements are all in memory at once (synchronous), or maybe they are arriving over the network over an interval of time (asynchronous). Indeed, we will see that RxJS has its own map operator, whose semantics aren't so far removed from that of Array.prototype.map."),(0,o.kt)("p",null,"Another thing to note about Solution 2 is that it is ",(0,o.kt)("em",{parentName:"p"},"composable"),", meaning we could chain or ",(0,o.kt)("em",{parentName:"p"},"pipe")," a sequence of operations together. For plain Javascript code, composition is mostly based on the return value of the function : if map() does return a new Array, we can call another function on this result. Composition will be explained in more detail in the section on operators, so don't worry about it right now. The reason it keeps coming up is because composition of operators is one of the things that makes RxJS so powerful. Should you choose to one day venture into the lands of a language like Haskell, you'll see that composition is one of the foundations of functional programming - it's not a concept that's unique to arrays or RxJS."),(0,o.kt)("h2",{id:"reactive-programming"},"Reactive Programming"),(0,o.kt)("p",null,"Reactive Programming is being able to work with an asynchronous stream of data. You can think of this as a pipe, where data is flowing from one end to the other. You can then observe this stream of data and do something with it - react - like apply some business logic as the data flows through the pipe. These data streams can be anything, from HTTP Requests, Mouse and Keyboard events, Data from Sensors, Push Notifications, or anything that can happen. For instance, take a chat application, where two people are having a chat. Whenever a new message arrives, could be in the form of text or a reaction to the previous message, you need to react accordingly and update the UI appropriately."),(0,o.kt)("p",null,"ReactiveX (Rx), which RxJS is an implementation of, gives you a set of tools to help you compose data streams. These tools are known as ",(0,o.kt)("em",{parentName:"p"},"operators")," and can be used to create new data streams, combine, transform, filter, join, handle errors, etc in your data streams."),(0,o.kt)("p",null,"The main goal of such an approach will be to handle nicely common issues we can have when dealing with asynchronous streams of data, like the callback hell. This expression refers to the callback function used in asynchronous functions like this (the second argument of addEventListener):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"document.getElementById('test').addEventListener('click', (event) => {\n  console.log(event.target);\n});\n")),(0,o.kt)("p",null,"This event listener is producing a stream of values, values emitted over time at each user click, and this stream virtually never completes."),(0,o.kt)("p",null,"When we will want to deal with other operations, we will have to nest the next calls in each callback function. Not only will it become hard to read, but the error handling will be very complicated if not impossible. In addition, we will have to work with streams of data that never complete (like the click event) and some that do complete (like a timeout or an Ajax call)."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"document.getElementById('test').addEventListener('click', (event) => {\n  console.log(event.target);\n  setTimeout(() => {\n    $.ajax({ params }).then((res) => {\n      // deal with result\n    });\n  }, 400);\n});\n")),(0,o.kt)("p",null,"In this pseudo code, we can see callback being nested, and we see that this will cause issues very soon, like ",(0,o.kt)("em",{parentName:"p"},"what happens if user clicks multiple times ?")," or ",(0,o.kt)("em",{parentName:"p"},"how do we cancel the operation ?")),(0,o.kt)("p",null,"In order to deal with these streams of data, RxJs will introduce much more elegant and powerful tools such as Observables that will be discussed in the next section."),(0,o.kt)("h2",{id:"the-iterator-and-observer-patterns"},"The Iterator and Observer patterns"),(0,o.kt)("p",null,'Iterables - data types that implement the "iterator" interface - are pretty common in Javascript. Perhaps the most common example is the array. Iterables are usually consumed using a ',(0,o.kt)("inlineCode",{parentName:"p"},"next")," method. Consumers of an iteratable tend to pull data from the producer by using the ",(0,o.kt)("inlineCode",{parentName:"p"},"next")," method. The consumer is the one in control of the flow of data."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"var arr = ['a', 'b', 'c'];\nvar iterator = arr.keys();\n\nconsole.log(iterator.next()); // { value: 0, done: false }\nconsole.log(iterator.next()); // { value: 1, done: false }\nconsole.log(iterator.next()); // { value: 2, done: false }\nconsole.log(iterator.next()); // { value: undefined, done: true }\n")),(0,o.kt)("p",null,"Note that the last value has done property set to true, meaning we ",(0,o.kt)("em",{parentName:"p"},"pulled")," all data from the iterator."),(0,o.kt)("p",null,"By contrast, in the observer pattern, the publisher of the data ",(0,o.kt)("em",{parentName:"p"},"pushes")," data to its subscribers, so it is in control of the flow of data."),(0,o.kt)("p",null,"The concept is pretty straightforward. There is an object containing state that will change over time. This is known as the subject in the classical Observer Pattern. All this subject does is accept callback functions from observers, which are objects that want to be notified whenever the subject's state changes. Whenever such a state change happens, the subject loops through all of the observer callbacks, and invokes them with the new state as an argument."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"class Subject {\n  constructor() {\n    this.callbacks = [];\n  }\n\n  subscribe(fn) {\n    this.callbacks.push(fn);\n  }\n\n  publish(data) {\n    this.callbacks.forEach((fn) => fn(data));\n  }\n}\n\n// usage\nconst subject = new Subject();\nconst observer1 = (data) => console.log(`Observer1 received data: ${data}`);\n\nsubject.subscribe(observer1);\ncounter = 0;\n\nsetInterval(() => {\n  subject.publish(`test data ${++counter}`);\n}, 1000);\n")),(0,o.kt)("p",null,"The classic observer pattern has been a staple of web development for many years. However, it provides no way of containerizing events, meaning we can't compose streams out of subject events. Ideally, we'd have some data structure that enables us to do this."),(0,o.kt)("p",null,"RxJS improves upon this classical observer pattern by introducing a more robust interface for observers, one that supports not just a method for publishing data (onNext), but also methods for notifying observers of errors (onError), as well as when there is no more data to consume (onComplete). Note that by contract, error and complete are exclusive, you either have one OR the other.\nIn doing this, the RxJS makes the observer pattern symmetric to the iterator pattern, in some sense."),(0,o.kt)("p",null,"Soon, we'll see how to implement a simple Observable class."),(0,o.kt)("h2",{id:"streams-of-data"},"Streams of Data"),(0,o.kt)("p",null,"We've seen how thinking about Arrays can be useful for understanding operators like map and filter, and composition over containers in general. So it should come as no surprise that they will provide a glimpse into streams."),(0,o.kt)("p",null,"In the Haskell - functional programming world, a stream is just an infinite list (array). Since Javascript has no native notion of an infinite array, let's think about how one differs from a regular array."),(0,o.kt)("p",null,"Consider the following, finite array:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"const arr = [1, 2, 3, 4, 5];\n\narr.map((x) => x + 1); // [2,3,4,5,6]\n")),(0,o.kt)("p",null,"In this case, ",(0,o.kt)("inlineCode",{parentName:"p"},"arr")," is finite. It's declared, and all of its values are in memory at once. We can synchronously iterate over it using Array.prototype.map, to produce a new array (",(0,o.kt)("inlineCode",{parentName:"p"},"[2,3,4,5,6]"),")."),(0,o.kt)("p",null,'Because this array is finite, we "know" when it ends - it has length of five in this case. We already know that arrays are composable containers, so we can do things like map, filter, flatMap, reduce, etc, over them. How convenient.'),(0,o.kt)("p",null,'But what about an "infinite array" ? Maybe you have an array that you\'d like to use to model mouse click events, or mousemover events. How would you ever know when you are finished ? A user could click or move the mouse at any time, so this theoretical array would be infinite in some sense - we could never know when it would end.'),(0,o.kt)("p",null,'And that\'s not really a problem, we could just listen for events and "push" these new events into some shared array state\u2026'),(0,o.kt)("p",null,'Still, it would be nice to have something a little more appropriate for handling asynchronicity. Like a data structure that is designed to work with potentially asynchronous, potentially infinite stream of data, while offering composable operators (map, filter, and friends). This is where observables shine. They provide us with a useful interface for consuming "infinite" streams of data.'),(0,o.kt)("p",null,"This will all be clearer with a concrete example, so let's build a simple observable."),(0,o.kt)("h2",{id:"observables---an-implementation-of-the-observer-pattern"},"Observables - an implementation of the Observer pattern"),(0,o.kt)("p",null,"Here's a simple implementation of an observable class, along with a static 'of'' method."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ts"},"class Observable {\n  /** Internal implementation detail */\n  _subscribe;\n\n  /**\n   * @constructor\n   * @param {Function} subscribe is the function that is called when the\n   * observable is subscribed to. This function is given a subscriber/observer\n   * which provides the three methods on the Observer interface:\n   * onNext, onError, and onCompleted\n   */\n  constructor(subscribe) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  static of(...args) {\n    return new Observable((obs) => {\n      args.forEach((val) => obs.onNext(val));\n      obs.onCompleted();\n\n      return {\n        unsubscribe: () => {\n          // just make sure none of the original subscriber's methods are never called.\n          obs = {\n            onNext: () => {},\n            onError: () => {},\n            onCompleted: () => {},\n          };\n        },\n      };\n    });\n  }\n\n  // public api for registering an observer\n  subscribe(onNext, onError, onCompleted) {\n    if (typeof onNext === 'function') {\n      return this._subscribe({\n        onNext: onNext,\n        onError: onError || (() => {}),\n        onCompleted: onCompleted || (() => {}),\n      });\n    } else {\n      return this._subscribe(onNext);\n    }\n  }\n}\n\nconst obs = Observable.of(1, 2, 3, 4);\n\nobs.subscribe(console.log); // prints 1,2,3,4\n")),(0,o.kt)("p",null,"In this example, we take a pseudo list of values and turn it into a stream of values, this is the of() method. Basically, nothing happens with an Observable until we subscribe to it, the ",(0,o.kt)("em",{parentName:"p"},"obs")," object is some blueprint of a stream of values."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"(Note: if keeping this example implementation makes sense, then explain it in more detail)")),(0,o.kt)("h2",{id:"operators---composition-with-observables"},"Operators - composition with Observables"),(0,o.kt)("p",null,"Way back in the section on declarative and imperative programming, we talked about Array.prototype's map function. We saw that it lets us apply a function to each element in an array. More generally, a map applies a transformation function (in our example, add1) over some container (in our example, the array x). RxJS has its own map. It's an example of an ",(0,o.kt)("em",{parentName:"p"},"operator"),". In the case of RxJS, the container is not an array but an observable. Other than that, many of the concepts are similar! ( ",(0,o.kt)("strong",{parentName:"p"},"Edit: In a more advanced guide, it might be fun to talk about the difference between array's map, which will map over every element before moving to the next operation, and Observables, which iirc are transducers and instead process a single element through each operator in the pipeline before moving on")," )"))}m.isMDXComponent=!0}}]);